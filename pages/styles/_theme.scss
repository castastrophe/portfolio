@use "sass:map";
@use "sass:meta";
@use "sass:list";
@use "sass:string";
@use "functions" as *;

$brand-color: hsl(313deg 80% 48%);

$tokens: (
    'font': (
        'family': (
            'primary': '"Roboto", "Lato", "Helvetica Neue", Helvetica, Arial, serif',
            'heading': '"Roboto", "Lato", "Helvetica Neue", Helvetica, Arial, serif',
            'code': '"PT Mono", monospace',
        ),
    ),
    'spacing': (
        'vertical': '10px',
        'horizontal': '10px',
    ),
    'color': (
        'text': (
            'primary': ( 'light': #333, 'dark': #fff ),
            'accent': ( 'light': $brand-color, 'dark': hsl(313deg 68% 78%) ),
        ),
        'link': ( 'light': $brand-color, 'dark': hsl(313deg 68% 78%) ),
        'surface': (
            'primary': ( 'light': #fff, 'dark': #111 ),
            'accent': ( 'light': hsl(313deg 68% 78%), 'dark': hsl(313deg 80% 48%) ),
            'subtle': ( 'light': #f5f5f5, 'dark': #222 ),
        ),
        'ui': (
            'primary': ( 'light': #cdcdcd, 'dark': #6c6a6a ),
            'accent': ( 'light': hsl(313deg 57% 44%), 'dark': hsl(313deg 96% 72%) ),
            'subtle': ( 'light': #efefef, 'dark': #afafaf ),
        ),
    )
) !default;

/// Get a value from the tokens map by the key
///
/// @param {string} $key - The key to get the value from (e.g. 'color.brand', 'color.content.accent')
/// @note Do not include the 'light' or 'dark' suffixes in the key as they return the light-dark function
/// @note You can leave off the 'primary' identifier if you want because it returns as the default value for it's parent key
/// @param {map} $map - The map to get the value from (default: $tokens)
/// @return {any} The value from the map
/// @example
///   get('color.brand')
///   get('color.content')
///   get('color.content.accent')
@function get($key, $map: $tokens) {
    $keys: string.split($key, '.');

    @each $key in $keys {
        $value: map.get($map, $key);

        // If the value is not a map, return the resolved value. Rejoice!
        @if meta.type-of($value) != 'map' {
            @return $value;
        }

        @else if not $value or $value == null {
            // Check for a 'primary' key or the 'light'/'dark' set
            @if map.has-key($value, 'primary') {
                $value: map.get($value, 'primary');
            }

            @else if map.has-key($value, 'light') {
                $value: 'light-dark($value.light, $value.dark)';
            }
        }
    }

    @if not $value {
        @warn "[get()]: The key `#{$key}` not found in tokens data map";
        @return null;
    }

    @return $value;
}

/// Print the tokens to the screen
/// @param {map} $map - The map to print the tokens from (default: $tokens)
/// @param {list} $list - The list of keys to print the tokens from (default: ('theme'))
///
@mixin print-tokens($map: $tokens, $list: ('theme')) {
    @each $key, $value in $map {
      // Next, if the value is a map, we need to nest the function call and dig deeper
      @if meta.type-of($value) == 'map' {
        $keys: map.keys($value);

        // First: check if the map has both 'light' and 'dark' keys so we can skip the nesting and use the light-dark function
        @if list.index($keys, 'light') and list.index($keys, 'dark') {
          #{join-list(list.append($list, $key))}: light-dark(map.get($value, 'light'), map.get($value, 'dark'));
        }

        @else {
          @include print-tokens($map: $value, $list: list.append($list, $key));
        }
      }

      @else {
        #{join-list(list.append($list, $key))}: #{$value};
      }
    }
  }
